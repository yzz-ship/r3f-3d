(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4614],{4400:(e,t,r)=>{Promise.resolve().then(r.bind(r,7261))},7261:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>v});var n=r(5155),i=r(2115),o=r(7558),s=r(4688),l=r(5377);function a(){let{scene:e}=(0,l.p)("".concat("/r3f-3d","/assets/models/Duck/glTF/Duck.gltf"));return(0,n.jsx)(n.Fragment,{children:(0,n.jsx)("primitive",{object:e})})}var c=r(3264),u=r(2421);let d=e=>e,h=e=>{let t=(0,u.y)(e),r=e=>(function(e,t=d){let r=i.useSyncExternalStore(e.subscribe,()=>t(e.getState()),()=>t(e.getInitialState()));return i.useDebugValue(r),r})(t,e);return Object.assign(r,t),r},m=0,f=(e=>e?h(e):h)(e=>(c.h_9.onStart=(t,r,n)=>{e({active:!0,item:t,loaded:r,total:n,progress:(r-m)/(n-m)*100})},c.h_9.onLoad=()=>{e({active:!1})},c.h_9.onError=t=>e(e=>({errors:[...e.errors,t]})),c.h_9.onProgress=(t,r,n)=>{r===n&&(m=n),e({active:!0,item:t,loaded:r,total:n,progress:(r-m)/(n-m)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));var x=r(9957);function p(){let{progress:e}=f();return(0,n.jsx)(x.E,{center:!0,children:(0,n.jsxs)("div",{style:{color:"white",fontSize:"24px",width:"200px",textAlign:"center"},children:["Loading: ",Math.round(e),"%",(0,n.jsx)("div",{style:{width:"100%",height:"10px",background:"rgba(255,255,255,0.2)",marginTop:"10px"},children:(0,n.jsx)("div",{style:{width:"".concat(e,"%"),height:"100%",background:"white",transition:"width 0.1s"}})})]})})}function v(){return(0,n.jsxs)(o.Hl,{dpr:[1.5,2],fallback:(0,n.jsx)("div",{children:"Sorry no WebGL supported!"}),children:[(0,n.jsx)(s.N,{enableDamping:!0,dampingFactor:.05}),(0,n.jsx)("ambientLight",{intensity:5}),(0,n.jsx)(i.Suspense,{fallback:(0,n.jsx)(p,{}),children:(0,n.jsx)(a,{})})]})}},9957:(e,t,r)=>{"use strict";let n,i;r.d(t,{E:()=>y});var o=r(9630),s=r(2115),l=r(2669),a=r(3264),c=r(5355);let u=new a.Pq0,d=new a.Pq0,h=new a.Pq0,m=new a.I9Y;function f(e,t,r){let n=u.setFromMatrixPosition(e.matrixWorld);n.project(t);let i=r.width/2,o=r.height/2;return[n.x*i+i,-(n.y*o)+o]}let x=e=>1e-10>Math.abs(e)?0:e;function p(e,t,r=""){let n="matrix3d(";for(let r=0;16!==r;r++)n+=x(t[r]*e.elements[r])+(15!==r?",":")");return r+n}let v=(n=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>p(e,n)),g=(i=e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1],(e,t)=>p(e,i(t),"translate(-50%,-50%)")),y=s.forwardRef(({children:e,eps:t=.001,style:r,className:n,prepend:i,center:p,fullscreen:y,portal:b,distanceFactor:M,sprite:P=!1,transform:w=!1,occlude:E,onOcclude:j,castShadow:S,receiveShadow:W,material:$,geometry:k,zIndexRange:F=[0x1000037,0],calculatePosition:z=f,as:R="div",wrapperClass:_,pointerEvents:T="auto",...A},I)=>{let{gl:N,camera:L,scene:C,size:q,raycaster:H,events:D,viewport:O}=(0,c.A)(),[G]=s.useState(()=>document.createElement(R)),U=s.useRef(null),V=s.useRef(null),B=s.useRef(0),Y=s.useRef([0,0]),Z=s.useRef(null),J=s.useRef(null),K=(null==b?void 0:b.current)||D.connected||N.domElement.parentNode,Q=s.useRef(null),X=s.useRef(!1),ee=s.useMemo(()=>E&&"blending"!==E||Array.isArray(E)&&E.length&&function(e){return e&&"object"==typeof e&&"current"in e}(E[0]),[E]);s.useLayoutEffect(()=>{let e=N.domElement;E&&"blending"===E?(e.style.zIndex=`${Math.floor(F[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)},[E]),s.useLayoutEffect(()=>{if(V.current){let e=U.current=l.createRoot(G);if(C.updateMatrixWorld(),w)G.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{let e=z(V.current,L,q);G.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return K&&(i?K.prepend(G):K.appendChild(G)),()=>{K&&K.removeChild(G),e.unmount()}}},[K,w]),s.useLayoutEffect(()=>{_&&(G.className=_)},[_]);let et=s.useMemo(()=>w?{position:"absolute",top:0,left:0,width:q.width,height:q.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:p?"translate3d(-50%,-50%,0)":"none",...y&&{top:-q.height/2,left:-q.width/2,width:q.width,height:q.height},...r},[r,p,y,q,w]),er=s.useMemo(()=>({position:"absolute",pointerEvents:T}),[T]);s.useLayoutEffect(()=>{var t,i;X.current=!1,w?null==(t=U.current)||t.render(s.createElement("div",{ref:Z,style:et},s.createElement("div",{ref:J,style:er},s.createElement("div",{ref:I,className:n,style:r,children:e})))):null==(i=U.current)||i.render(s.createElement("div",{ref:I,style:et,className:n,children:e}))});let en=s.useRef(!0);(0,c.C)(e=>{if(V.current){L.updateMatrixWorld(),V.current.updateWorldMatrix(!0,!1);let e=w?Y.current:z(V.current,L,q);if(w||Math.abs(B.current-L.zoom)>t||Math.abs(Y.current[0]-e[0])>t||Math.abs(Y.current[1]-e[1])>t){let t=function(e,t){let r=u.setFromMatrixPosition(e.matrixWorld),n=d.setFromMatrixPosition(t.matrixWorld),i=r.sub(n),o=t.getWorldDirection(h);return i.angleTo(o)>Math.PI/2}(V.current,L),r=!1;ee&&(Array.isArray(E)?r=E.map(e=>e.current):"blending"!==E&&(r=[C]));let n=en.current;r?en.current=function(e,t,r,n){let i=u.setFromMatrixPosition(e.matrixWorld),o=i.clone();o.project(t),m.set(o.x,o.y),r.setFromCamera(m,t);let s=r.intersectObjects(n,!0);if(s.length){let e=s[0].distance;return i.distanceTo(r.ray.origin)<e}return!0}(V.current,L,H,r)&&!t:en.current=!t,n!==en.current&&(j?j(!en.current):G.style.display=en.current?"block":"none");let i=Math.floor(F[0]/2),o=E?ee?[F[0],i]:[i-1,0]:F;if(G.style.zIndex=`${function(e,t,r){if(t instanceof a.ubm||t instanceof a.qUd){let n=u.setFromMatrixPosition(e.matrixWorld),i=d.setFromMatrixPosition(t.matrixWorld),o=n.distanceTo(i),s=(r[1]-r[0])/(t.far-t.near),l=r[1]-s*t.far;return Math.round(s*o+l)}}(V.current,L,o)}`,w){let[e,t]=[q.width/2,q.height/2],r=L.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:i,left:o,bottom:s,right:l}=L,a=v(L.matrixWorldInverse),c=n?`scale(${r})translate(${x(-(l+o)/2)}px,${x((i+s)/2)}px)`:`translateZ(${r}px)`,u=V.current.matrixWorld;P&&((u=L.matrixWorldInverse.clone().transpose().copyPosition(u).scale(V.current.scale)).elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),G.style.width=q.width+"px",G.style.height=q.height+"px",G.style.perspective=n?"":`${r}px`,Z.current&&J.current&&(Z.current.style.transform=`${c}${a}translate(${e}px,${t}px)`,J.current.style.transform=g(u,1/((M||10)/400)))}else{let t=void 0===M?1:function(e,t){if(t instanceof a.qUd)return t.zoom;if(!(t instanceof a.ubm))return 1;{let r=u.setFromMatrixPosition(e.matrixWorld),n=d.setFromMatrixPosition(t.matrixWorld);return 1/(2*Math.tan(t.fov*Math.PI/180/2)*r.distanceTo(n))}}(V.current,L)*M;G.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}Y.current=e,B.current=L.zoom}}if(!ee&&Q.current&&!X.current)if(w){if(Z.current){let e=Z.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){let{isOrthographicCamera:t}=L;if(t||k)A.scale&&(Array.isArray(A.scale)?A.scale instanceof a.Pq0?Q.current.scale.copy(A.scale.clone().divideScalar(1)):Q.current.scale.set(1/A.scale[0],1/A.scale[1],1/A.scale[2]):Q.current.scale.setScalar(1/A.scale));else{let t=(M||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;Q.current.scale.set(r,n,1)}X.current=!0}}}else{let t=G.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){let e=1/O.factor,r=t.clientWidth*e,n=t.clientHeight*e;Q.current.scale.set(r,n,1),X.current=!0}Q.current.lookAt(e.camera.position)}});let ei=s.useMemo(()=>({vertexShader:w?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[w]);return s.createElement("group",(0,o.A)({},A,{ref:V}),E&&!ee&&s.createElement("mesh",{castShadow:S,receiveShadow:W,ref:Q},k||s.createElement("planeGeometry",null),$||s.createElement("shaderMaterial",{side:a.$EB,vertexShader:ei.vertexShader,fragmentShader:ei.fragmentShader})))})}},e=>{var t=t=>e(e.s=t);e.O(0,[1831,9367,8413,3562,4688,6176,5377,8441,1684,7358],()=>t(4400)),_N_E=e.O()}]);